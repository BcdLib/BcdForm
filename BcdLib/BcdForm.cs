using System;
using System.ComponentModel;
using System.Text;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.JSInterop;
using BcdLib.Core;
using BcdLib.Extensions;

namespace BcdLib
{
    public abstract class BcdForm : ComponentBase, IDisposable
    {
        public const string Prefix = "bcd-form";

        protected readonly IServiceScope ServiceScope;

        protected BcdForm()
        {
            ServiceScope = BcdServices.ServiceProvider.CreateScope();
            InitComponent();
        }

        protected BcdForm(string name) : this()
        {
            this.Name = name;
        }

        #region form properties

        /// <summary>
        /// The width of the form, in pixels
        /// </summary>
        public int Width { get; set; } = 520;

        /// <summary>
        /// Where the form is minimized
        /// </summary>
        public MinPosition MinPosition { get; set; } = MinPosition.RightBottom;

        /// <summary>
        /// form body's style
        /// </summary>
        public string BodyStyle { get; set; }

        /// <summary>
        /// Remove from DOM when closing. Default is true
        /// </summary>
        public bool DestroyOnClose { get; set; } = true;

        /// <summary>
        /// Unique identification. If it is not defined, it will be generated by default
        /// </summary>
        public string Name { get; set; } = "Bcd-" + Guid.NewGuid();

        /// <summary>
        /// Allow header to be displayed. Default is true
        /// </summary>
        public bool EnableHeader { get; set; } = true;

        /// <summary>
        /// Allow Mask to be displayed. Default is false
        /// </summary>
        public bool ShowMask { get; set; }

        /// <summary>
        /// the style of Mask, if <paramref name="ShowMask"/> is true.
        /// </summary>
        public string MaskStyle { get; set; }

        /// <summary>
        /// the title of form
        /// </summary>
        public string Title { get; set; } = "BcdForm";

        /// <summary>
        /// Allow minimization
        /// </summary>
        public bool MinimizeBox { get; set; } = true;

        /// <summary>
        /// Allow maximum
        /// </summary>
        public bool MaximizeBox { get; set; } = true;

        /// <summary>
        /// 
        /// </summary>
        public bool Visible { get; private set; }

        /// <summary>
        /// Allow drag
        /// </summary>
        public bool Draggable { get; set; }

        /// <summary>
        /// Drag is only allowed in the viewport, if <paramref name="Draggable"/> is true.
        /// </summary>
        public bool DragInViewport { get; set; } = true;

        #endregion

        protected abstract void InitComponent();

        public bool HasDestroyed { get; protected set; } = true;

        internal string GetHeaderCls()
        {
            return Draggable ? "draggable" : "";
        }

        internal string GetStyle()
        {
            return Visible ? "" : "display:none;";
        }

        internal string GetFormStyle()
        {
            if (_firstRender)
            {
                var sty = $"width: {Width}px;";
                _lastNormal = sty;
            }

            return _lastNormal;
        }

        private string _lastNormal;
        private bool _firstRender = true;

        #region Show

        /// <summary>
        /// Trigger before displaying form. The display can be cancelled by CancelEventArgs.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnShowingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Show form
        /// </summary>
        /// <returns></returns>
        public async Task ShowAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnShowingAsync(eventArgs);
            if (eventArgs.Cancel)
            {
                return;
            }

            if (!Visible)
            {
                Visible = true;
                if (HasDestroyed)
                {
                    HasDestroyed = false;
                    await BcdFormContainer.BcdFormContainerInstance.AppendFormAsync(this);
                }
                await InvokeStateHasChangedAsync();
            }
        }

        #endregion

        #region close

        /// <summary>
        /// Trigger before closing form. The close can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnClosingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Trigger before the form destroying (removing) from DOM. The destroy Can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnDestroyingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }


        /// <summary>
        /// Close form
        /// </summary>
        /// <returns></returns>
        public async Task CloseAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnClosingAsync(eventArgs);

            if (eventArgs.Cancel)
            {
                return;
            }

            if (Visible)
            {
                Visible = false;
                await InvokeStateHasChangedAsync();

                if (DestroyOnClose && !HasDestroyed)
                {
                    HasDestroyed = true;
                    eventArgs = new CancelEventArgs(false);
                    await OnDestroyingAsync(eventArgs);

                    if (eventArgs.Cancel)
                    {
                        return;
                    }
                    await BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);

                    await InvokeStateHasChangedAsync();
                }
            }
        }

        #endregion

        #region min max

        /// <summary>
        /// last form state
        /// </summary>
        private FormState LastState { get; set; }

        private FormState _formState;

        /// <summary>
        /// form's state: maximize, minimize or normalize
        /// </summary>
        public FormState FormState
        {
            get => _formState;
            private set
            {
                LastState = _formState;
                _formState = value;
            }
        }

        internal string GetFormState()
        {
            return IsMin()
                ? $"{FormState.ToCls()} {MinPosition.ToCls()}"
                : FormState.ToCls();
        }

        /// <summary>
        /// Minimize form
        /// </summary>
        public void Min()
        {
            FormState = FormState.Min;
            BcdFormContainer.MinFormCount += 1;
        }

        /// <summary>
        /// Maximize form
        /// </summary>
        public void Max()
        {
            if (IsMin())
            {
                BcdFormContainer.MinFormCount -= 1;
            }

            FormState = FormState.Max;
        }

        /// <summary>
        /// Restore form
        /// </summary>
        public void Restore()
        {
            if (IsMin())
            {
                BcdFormContainer.MinFormCount -= 1;
            }

            FormState = FormState.Normal;
        }

        /// <summary>
        /// Trigger Max or Restore
        /// </summary>
        internal void TriggerMaxBox()
        {
            if (IsMax())
            {
                Restore();
            }
            else if (IsMin())
            {
                if (LastState.IsNormal())
                {
                    Restore();
                }
                else
                {
                    Max();
                }
            }
            else
            {
                Max();
            }
        }

        /// <summary>
        /// Determine whether the form is minimized
        /// </summary>
        /// <returns></returns>
        public bool IsMin()
        {
            return FormState.IsMin();
        }

        /// <summary>
        /// Determine whether the form is maximized
        /// </summary>
        /// <returns></returns>
        public bool IsMax()
        {
            return FormState.IsMax();
        }

        /// <summary>
        /// Determine whether the form is normalized
        /// </summary>
        /// <returns></returns>
        public bool IsNormal()
        {
            return FormState.IsNormal();
        }

        #endregion

        #region Adapter or proxy

        /// <summary>
        /// jsRuntime.InvokeVoidAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async Task JsInvokeVoidAsync(string func, params object[] args)
        {
            if (BcdServices.TryGetJsRuntime(out var jsRuntime))
            {
                await jsRuntime.InvokeVoidAsync(func, args);
            }
            else
            {
                // TODO 
            }
        }

        /// <summary>
        /// jsRuntime.InvokeAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async ValueTask<T> JsInvokeAsync<T>(string func, params object[] args)
        {
            if (BcdServices.TryGetJsRuntime(out var jsRuntime))
            {
                return await jsRuntime.InvokeAsync<T>(func, args);
            }
            else
            {
                // TODO
                return await new ValueTask<T>(default(T));
            }
        }

        /// <summary>
        /// StateHasChanged adapter
        /// </summary>
        protected void InvokeStateHasChanged()
        {
            BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChanged();
        }

        /// <summary>
        /// InvokeAsync(StateHasChanged) adapter
        /// </summary>
        /// <returns></returns>
        protected Task InvokeStateHasChangedAsync()
        {
            return BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChangedAsync();
        }

        #endregion

        #region dispose

        /// <summary>
        /// Has the object been released
        /// </summary>
        protected bool IsDisposed { get; private set; }

        /// <summary>
        /// If rewriting, be sure to base.Dispose Call this function
        /// </summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (!IsDisposed)
            {
                if (disposing)
                {
                    ServiceScope?.Dispose();
                    // destroy DOM from the Document
                    _ = BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);
                }
            }
            IsDisposed = true;
        }

        /// <summary>
        /// dispose the form
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~BcdForm()
        {
            // Finalizer calls Dispose(false)
            Dispose(false);
        }

        #endregion

        internal async Task AfterRenderAsync()
        {
            if (_firstRender && Draggable)
            {
                await JsInvokeVoidAsync(JsInteropConstants.EnableDraggable,
                    $"#{Name} .bcd-form-header .bcd-form-title", $"#{Name} .bcd-form", DragInViewport);
            }

            if (IsMin())
            {
                var lastNormal = await JsInvokeAsync<string>(JsInteropConstants.MinResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }
            else if (IsMax())
            {
                var lastNormal = await JsInvokeAsync<string>(JsInteropConstants.MaxResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }


            // ReSharper disable once MethodHasAsyncOverload
            AfterBcdRender(_firstRender);
            await AfterBcdRenderAsync(_firstRender);
            if (_firstRender)
            {
                _firstRender = false;
            }
        }

        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual void AfterBcdRender(bool firstRender)
        {
        }
        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual Task AfterBcdRenderAsync(bool firstRender)
        {
            return Task.CompletedTask;
        }
    }
}
